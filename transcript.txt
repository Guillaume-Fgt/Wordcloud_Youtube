in this video i'm going to take you
through writing unit tests for existing
code show you the kinds of things you
encounter while doing that and how to
solve them in a perfect world you would
never have to write unit tests for
existing code because you would be
following test driven development where
you write your tests along or even
before you write the actual code but
sometimes you have to deal with existing
code that's not properly tested but
again sometimes
all of the time it's good practice to
add unit tests especially in that case
because tests help you refactor your
code and design it better so it's easier
to test and easier to change later on
i'm going to show you a few examples of
this today my goal with this channel is
to help you make better software design
decisions i've written a guide that
provides you with a starting point it's
totally free you can get your copy at
iamcodes.com
design guide it contains the seven steps
that i follow myself when i design a
piece of software and i think it will
help you avoid some of the mistakes i
made in the past so aryancodes.com
design guide the link is also in the
description of this video today's
example is an example that i come back
to from time to time it's a point of
sale system i have a main function here
that creates an order it adds a couple
of line items and then
calls a function called pay order that
pays the order pay order is defined in
the payment of file and it gets an order
as parameter
but there are some checks like if the
total of the order is zero then it's
going to raise a value error that you
can't pay an order with that total then
it reads the card the month and the year
from the input it creates a payment
processor with an api key and then it
creates a charge via that payment
processor on the card for the total of
the order and then it sets the order to
the paid status so the processor the
payment processor doesn't do all that
much there is a charge method that
validates the card and validating the
card means that it checks the something
called the loon checksum which checks
that the number adheres to certain
conditions like specifically if the sum
of the digits at the odd indices plus
the sum of the digits at the even
indices times 2 is divisible by 10. more
or less it's not really important what
this does exactly you can look it up if
you want to it's not important for the
example but it checks that and it checks
that the date and the time of the card
is actually in the future and we're not
trying to charge a card that's not valid
anymore so that's a validate card
validate card is called by charts if the
card is not valid for some reason it
raises a value error and otherwise it's
going to print that it will charge the
card number for a certain amount now
this is not really how a payment
processor works of course there's no
actual charge here i'm just printing
something but normally you would use
this kind of class to interface with a
payment processor like paypal or stripe
the order class is pretty simple there
is a line items list and there is a
status which is either open or paid line
item has a name a price and a quantity
and there are some properties like
computing the total price for a line
item computing the total price for an
order that just sums over the totals for
each of the line items and then we have
a pay method that for the moment does
nothing else than just setting the
status to or the status stop paid so
when we run this code then this is what
happened so i just enter some card
number here i don't think this is going
to be valid card but it doesn't matter
expiry month 12
2024 so now you see we're getting a
value error that this is an invalid card
let's try that again i have a test card
number that is actually a valid number
according to the loon checksum so now
when i enter a valid expiry month and
year then it is actually correctly
charging the card if i run this one more
time but
i provide that same valid number but i
provide a date in the past like so then
we're gonna get the invalid card value
error again so i'm going to use this
code as a starting point to add some
unit test to it and show you what
happens when you do and the things that
you need to think about there's a couple
of things that you will encounter as
well in lots of other code if you try to
add unit tests like in the payment
method we have input for example and
we're creating an object that connects
perhaps with the server so how do we
deal with those things these are common
things that you have to think about when
you write tests of your code and of
course if you use test driven
development you will have written the
test before you write the code but here
we just got this code and we have to
make sure that it's stable and robust so
we're gonna have to write some tests for
it now to prepare for this i have
installed pi test and pi test coverage
which are useful for running tests and
also creating coverage reports i don't
know where we're at in terms of how much
of the code we've covered so what we'll
do is all these things order payment
processor etc there in the folder pay
which is the point of sale system so let
me add another folder here called
tests and i'll add an init dot pi file
as well
so python can actually find it easily
and now we can start writing tests for
all of this code now general advice if
you write unit tests you have to think
about where you start on one end you can
start with things that are simple to
test like for example order and line
item they're probably going to be pretty
simple to test so writing tests for
those that's a pretty good start and
that's already going to give you some
extra security about
the stability of your code another thing
you can do to determine the priority in
which you write a unit test is to think
about which parts of your code are going
to be responsible for the most breaks
which are the the most dangerous pieces
of code basically and actually line item
and order are pretty important because
their core data structures and making
sure that total actually computes the
correct total is quite important if you
create a point of sale system so i'm
going to start with writing some tests
for order and line item just so we can
get off easy you know and then we move
on to the more complicated things later
in the video so let me start by line
item so i'm going to create a file here
called test line item
dot pi there we go and here i can now
write my tests so by the way if i'm
running pi test at the moment like so
then nothing has happened it doesn't
find any test which is correct because
there are no tests right so i'm going to
test line item now if you look at the
line item class it's it's not much it it
represents something that has a name a
price and a quantity and there's a
property so we probably want to make
sure that the property works correctly
and you can imagine that we want to test
at least two varieties having a quantity
of one which is the default value and
choosing another quantity and then make
sure that the total is actually correct
so first step is to import line item
because we're going to need that in
order to test it
so we're going to import line item and
now with pi test it's actually really
easy to write a couple of tests we just
put test underscore in front of our
testing function
so let's test a line item default
it's going to have a return type of num
we create a line item
name test price let's say 100 and we
don't provide a quantity because we want
to use the default value
and with bytes you can simply use assert
to verify that a certain
value is as you expected so the assert
here is that line item dot total
equals
100 or one dollar so let's save this and
i just want to make sure that when i run
pi test it discovers the test correctly
and it seems to have done that it
detected one test in test line item and
that test has passed so
great news for completeness let's add
another one
and here we're also going to create a
line item
but now
let's take a price of
i don't know 200 and we're gonna take a
quantity of
five
and now we want to assert that
line
item dot
total equals
1 000.
run by test again
and we get our to test that pass if we
create a coverage report so that's
done with pi test dash dash
coverage so now you can see that in
order we have reached 91
coverage we didn't test the order class
yet so it makes sense that we don't get
100 coverage so let's also add a couple
of tests for the order class them test
order.pi so here we're going to need
from pay.order import
order and what do we need to test here
well we should probably test that
line items if it's empty that we're
going to get a total of zero and we want
to make sure that if we create a line
item that the total is the same as the
total of that line item i have already
prepared these tests this is what they
look like we have an empty order so
there we have order total equals zero we
have an order with a single line item
that has a price of one dollar and we
want to make sure that the total is one
dollar and
you can add yet another one
where we're going to add multiple line
items so we're going to insert this and
then of course we expect the total to be
200 and now let's
run test again
there we go and now you see order has 95
so we didn't do everything yet because
what we still didn't do is test the pay
method of order using coverage you can
create html coverage report that are
actually going to show you which part of
the code you still need to test you do
that by
writing coverage html so now it's going
to create an html report inside the
folder way around the test so that's
right here and this is what it looks
like when you look at that coverage
report so if you look at order
for example you see that we didn't test
yet the the pay method so let's also
test that now
so now i'm going to do a test order pay
it's also going to return on and then i
create an order
and i do order dot pay
and now we just have to assert that
order
dot
status
equals
order status which we need to import dot
state like so let's run those tests one
more time
and now you see order has 100
coverage by the way if you're enjoying
the video so far give it a like it
really helps with the youtube algorithm
to make the video reach more people
thank you so order a line item those two
were pretty simple where it gets harder
is testing the payment function we have
here and testing the processor because
there is a couple of more complicated
things happening so what i will do as a
first step is just write
a couple of tests for these things
and i'm going to show you the
limitations of doing it with the current
version of the code and then later on
i'm going to refactor the code to make
testing it easier while improving the
design at the same time so now let's add
another file called test
and this is going to test the payment
processor so one thing we are going to
need is
from pay dot processor
import
payment processor right because that's
what we're going to test and payment
processor if you look at
how it's defined it needs an api key so
here i have the correct api key i'm just
putting it here in the test code itself
normally you should never do this i'll
show you in a minute a better way to
deal with api keys and tests but for now
i'm just going to do this and fix it
later so just to be clear never actually
add api keys to your code and certainly
never commit it to a git repository
because that opens you up to all kinds
of security issues so this is just a
temporary thing that i'm using to show
you to add test don't ever do this in
real production code so one thing we can
test we actually don't even need this
api key for that is that what happens if
an api key is invalid so we're going to
test api key
invalid
and there we're going to create a
processor
which is a payment processor would
provide an empty api key which is
obviously not valid and now we're going
to use the process to charge a credit
card which obviously is not going to
work if you want to test that something
raises an error in pi test then you have
to put it within a with statement so
let's import pi test
and then you can write
with
pi test dot raises and we expect this to
be a
value error
and now i'm going to take
these two lines and indent them so we
expect that if you run these two lines
that they're going to raise a value
error so now if i run the test again
we see that still all the tests pass and
we are also testing processor now which
has not 100 coverage which makes sense
because we're not calling yet all the
methods now what do we want to test
precisely let's take a look at processor
so there is the charge method that has a
couple of options like that the card is
not valid that the api key is not valid
so that we checked there is also a
validate card method that we might want
to check we might want to do tests on
the loon checksum so there is a bunch of
tests that we want to add so for example
one test that we could add is to do a
test with a card that has a valid date
both test card
valid
date
and here we can create a processor
we provide the api key we've defined and
now we're going to charge
with
these values basically because these are
valid this is a valid credit card
according to this checksum and the date
is also valid so let's add that here and
now we can test that this actually works
correctly so let's run the test again
and we see indeed that this works
correctly and also our coverage
percentage has now increased those other
things you can test we can also test for
example a card with an invalid date
so let's say we want to change the year
to
1900 and now we expect this to raise a
value error again so we're going to use
the with pi test dot raises
value error
like so
let's run the test again
and we see tests are still passing so
this is how you build up your collection
of unit tests right you you check every
time like hey i'm adding tests and i'm
continuously running those tests
checking that was still good
everything's still working if you find a
bug you can fix it run the test again
and verify that everything is working as
you expect it to so i have a couple of
other tests here that i added just now
already to prepare so for example i
added a test to check that a number is
invalid according to this
loom checksum with a valid number i
checked that a card number was valid
that card was invalid so change this
number here to an invalid number and
then verify that that actually raises a
value error so again when we run these
tests now we're running in total 12
tests that pass and order processor then
are both at 100 coverage which is really
nice so even for processor we could add
test relatively easily we added a bit of
complication to the test because we had
to check that something raised the value
error but there's no way around that
that's just something that we have to
test but the way that we're dealing with
api keys i'm not totally happy about and
there's a couple of other things that i
think should be separated more here like
the loon checksum for example that's now
part of the payment processor but it's
actually if you look at the code it's
completely independent there is no usage
of self in this method so it could
actually be a separate function so that
will deal with when we refactor the code
but those things you already start to
notice when you look at a test for
example here we are simply testing this
method but we do have to create a
payment processor with an api key and
that just makes things really
complicated really fast so if we can
separate this out more if we can
separate this function from the payment
processor object then our test here is
also going to be much simpler that just
shows that tests can really help you
analyze the code and indicate where
there are issues in the code and what
you can do to make tests simpler because
often if you succeed in making your unit
test simpler it also means that the
overall design of the code is often
better so that's something to keep in
mind so the final part of the program
that i want to test and this one is
actually pretty complicated to test
that's the pay order function this gets
an order but it creates a payment
processor with an api key it has input
it charges the card and sets the order
to pay so there's a lot of things are
happening here lots of interactions and
because of that this
makes pay order actually pretty hard to
test so first let me create a
another test file called test payment so
we can put the payment test in there
let's say we just want to test a happy
case so we're going to import order
and what i want to do is simply test
paying an order
so what i do is i create an order
right and i'm going to add a line item
which we can import
and now what i want to do is call pay
order so let's import pay order
now the problem is this is not going to
work like this because pay order is
going to ask for input and we don't want
our tests to wait for input so if i run
the test now
you see that there's now an os arrow
because it's waiting for input which is
not what we want so in order to fix this
without refactoring the code
because we should actually refactor the
code but if we want to fix this without
refactoring we're going to need to mock
the input so if you're writing unit test
mocking means that you're replacing
objects replacing systems modules with a
mock version of that so that you can
test the thing that is using the system
so what we can do here is mock the input
reading part of of python to supply
let's say fake input instead of us
having to type it into the keyboard
so that the test can actually run and
for that what we're going to use is
something called a monkey patch which
means that we're patching the input with
something else i'm not sure what that
has to do with monkeys but i'm sure
there is a reason why it's called like
that and then we can replace the input
with that and run the test and see what
happens so what we're going to need for
that is from pi test
we're going to
import monkey patch which is a class and
if you want to use a monkey patch then
we need to put it as an argument in our
function so let's call this monkey patch
and this is of type
monkey patch surprisingly and now we can
use this object to patch certain things
specifically
monkey patch has something called
set attribute and that means you can
replace
functions in a module with something
else so what we can do for example is
use this to override the built-in input
reading system and if you look at the
payment function the pay order function
it reads three things card month and
year so we actually need to create a
function that in sequence provides these
three things to our test and here's a
little trick to achieve that so first
i'm going to define the inputs that will
need to be provided so in this case
that's the card number it's the month
and the card year those are the three
things that i want to provide and now
what i'm going to change is the
built-ins dot input so that's the input
reading system of python and i'm going
to replace that with a function a lambda
function
that doesn't take any arguments but that
is going to return
inputs
and then we're going to pop
the first element so input is then
slowly being cleared one element at a
time and it's provided as a result
of an input call and this should
actually be inputs so there we have it
so now we have patched the input let's
see what that does when we start running
the test again
like so and obviously you were actually
able to run the test because we've
patched the input but you can clearly
see this is not an easy test to create
and these kind of tricks that i'm
applying here they're kind of hard to
find if you look for testing code this
is not something that you can easily
find on stack overflow or something you
have to look around to figure this stuff
out there's not a problem here which is
that payment processor well in this case
it's a simple class that just does
nothing basically but you can imagine
that if you have an actual payment
processor it's going to communicate with
the server and doing an actual charge of
course we don't want our tests our
payment test to actually pay an order
because that would make our tests pretty
expensive pretty fast so normally what
you would also need to do in this case
is make sure that when you call pay
order that
it doesn't actually charge a credit card
because that's not what we want when we
run the test we simply want to test pay
order so what you also need to do in
this case is actually mock the payment
processor but that's also really hard
because payment processor is being
created inside the pay order method so
that also makes it pretty hard to test
actually when i refactor this code we're
going to use dependency injection
instead and that's going to really
simplify our tests a lot so just like i
used monkeypads to change the attributes
of inputs i can also use it to change
attributes and methods of payment
processor so for example what you can do
is i'm going to set the attribute of
payment processor which i need to import
now and i'm going to set check api key
so that it always returns true so that
we don't have this check and you can do
the same thing for the charge method
replace it with another method i won't
do it in this particular example but the
mechanism is exactly the same and when
we do this well it doesn't really change
anything in the current test setup
because it was already running but now
the check api key method is replaced by
a simple number function that always
returns true so the payment processor
doesn't have to communicate with the
payments server to verify the api key
because we're just using it for a test
and you can also set the attribute of
the charge method to do something really
simple so that you can actually test the
pay order method so let's do that as
well so i'm going to copy this and
insert the line here and we're going to
change the
method here to charts and let's create a
fake charge method here uh charge
mock and then let's see what we're going
to need in the charge methods
well we're going to need to card the
month and the year so let me just copy
this line um and then i'll put it in
here delete this and then let's rename
this to charge
mock and then this is just going to do
pass because we don't actually want to
charge the card and now we're going to
set charts to be charged mock like so
now let's
run the test again
and there we go now the tests pass
but as you can see i really don't like
this i'm replacing a bunch of different
methods here and doing all kinds of
monkey patching to make sure that i can
actually test this method and that's
just really ugly you can do actually
just to complete this first version of
the example you can also do an invalid
order so let's import pi tests
for this and
then here we have by test.raise and
there you see i'm using the same thing
so i have the
i have the inputs that i want to provide
so this is an invalid order because it's
an empty order there are no line items
so pay order is supposed to fail so
let's also run this just to be sure
and now we see we get 14 tests that pass
hey this is ariane from the future while
editing this video we noticed that it
was getting pretty long and i didn't
even get to the juicy part which is
refactoring the code and seeing what
that does to the unit testing code so
i'm going to save that up for next week
i hope you enjoyed this video if you did
give the like consider subscribing to my
channel if you want to learn more about
software design and software development
thanks for watching take care
see you next week